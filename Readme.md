
# Инструкция по работе с Git и GitHub 

Это краткая инструкция по работе с Git и GitHub, в которой будут рассмотрены основные термины, самые распространненные команды для работы с репозиториями. Помимо этого остановимся на работе с популярным сервисом  для хранения репозиториев GitHub, а так же на том, как передавать информацию от локального репозитория к удаленному и обратно, работать с репозиториями других авторов и отправлять запросы на редактуру в чужих репозиториях. 

## Что такое система контроля версий 

Система контроля версий - это программное обеспечение для облегчения работы с изменяющейся информацией. Система управления версиями позволяет хранить несколько версий одного и того же документа, при необходимости возврщаться к более ранним версиям, определять, кто и когда сделал то или иное изменение и многое другое. 


## Что такое git 

Git - это одна из реализаций распределенных систем контроля версий. Git позволяет управлять изменениями, создавать фиксации, ветки, а также сливать и удалять ветки.

## Подготовка репозитория 

Репозиторий - это хранилище файлов, поддерживающее версионность. Создать репозиторий можно с помощью команды *git init* 

# Определение состояния файлов

Основной инструмент, используемый для определения, какие файлы в каком состоянии находятся — это команда git status. Если вы выполните эту команду сразу после клонирования, вы увидите что-то вроде этого:

 >  git status

 >   On branch master
 > Your branch is up-to-date with 'origin/master'.
 
> nothing to commit, working tree clean

Это означает, что у вас чистый рабочий каталог, другими словами — в нем нет отслеживаемых измененных файлов. *Git* также не обнаружил неотслеживаемых файлов, в противном случае они бы были перечислены здесь. Наконец, команда сообщает вам на какой ветке вы находитесь и сообщает вам, что она не расходится с веткой на сервере. 

# Отслеживание новых файлов 

Для того чтобы начать отслеживать (добавить под версионный контроль) новый файл, используется команда *git add*. Чтобы начать отслеживание файла <имя файла>, вы можете выполнить следующее:

  >   *git add <имя файла>* 

Если вы снова выполните команду *status*, то увидите, что файл <имя файла> теперь отслеживаемый и добавлен в индекс.

## Создание сохранений 

Мы можем создавать "сохранения" наших версий файлов. Такие "сохранения" называются фиксациями или коммитами. Сделать коммит можно с помощью команды *git commit* и **ОБЯЗАТЕЛЬНО** использовать флаг *-m*, после чего в кавычках написать сообщение.

# Игнорирование файлов

Зачастую, у вас имеется группа файлов, которые вы не только не хотите автоматически добавлять в репозиторий, но и видеть в списках неотслеживаемых.  В таком случае, вы можете создать файл 

  >  .gitignore.

с перечислением шаблонов соответствующих таким файлам.

Хорошая практика заключается в настройке файла 
.gitignore до того, как начать серьёзно работать, это защитит вас от случайного добавления в репозиторий файлов, которых вы там видеть не хотите.

GitHub поддерживает довольно полный список примеров .gitignore файлов для множества проектов и языков 

[GitHub] (https://github.com/github/gitignore)

это может стать отправной точкой для .gitignore в вашем проекте.

## Журнал изменений 

# Просмотр индексированных и неиндексированных изменений

Если результат работы команды *git status* недостаточно информативен для вас — вам хочется знать, что конкретно поменялось, а не только какие файлы были изменены — вы можете использовать команду *git diff*. 

 Вы, скорее всего, будете использовать эту команду для получения ответов на два вопроса: что вы изменили, но ещё не проиндексировали, и что вы проиндексировали и собираетесь включить в коммит. Если *git status* отвечает на эти вопросы в самом общем виде, перечисляя имена файлов, *git diff* показывает вам непосредственно добавленные и удалённые строки — патч как он есть.

 Чтобы увидеть, что же вы изменили, но пока не проиндексировали, наберите git diff без аргументов:

   > git diff

   
## Перемещение между сохранениями 

Перемещаться между нашими сохранениями можно с помощью команды *git checkout*. Для этого достаточно применить команду *git checkout <номер коммита>*. 

Можно отменить изменения с помощью команд *git revert* и *git reset*.

*git revert <номер коммита>* отменит изменения до указнной версии и создаст новый коммит. 

*git reset --hard <номер коммита>* отменит изменения до указанной версии и сотрет всю историю изменений после этого коммита.


## Ветки 

Используя ветвление, Вы отклоняетесь от основной линии разработки и продолжаете работу независимо от неё, не вмешиваясь в основную линию. Во многих СКВ создание веток — это очень затратный процесс, часто требующий создания новой копии каталога с исходным кодом, что может занять много времени для большого проекта.

Некоторые люди, говоря о модели ветвления *Git*, называют ее «киллер-фича», что выгодно выделяет Git на фоне остальных СКВ. Что в ней такого особенного? Ветвление Git очень легковесно: операция создания ветки выполняется почти мгновенно, переключение между ветками туда-сюда, обычно, также быстро. В отличие от многих других СКВ, *Git* поощряет процесс работы, при котором ветвление и слияние выполняется часто, даже по несколько раз в день. Понимание и владение этой функциональностью дает вам уникальный и мощный инструмент, который может полностью изменить привычный процесс разработки.

Новая ветка создается с помощью команды 

*git branch <название ветки>* 

# Переключение веток 

Для переключения на существующую ветку выполните команду *git checkout*. Давайте переключимся на ветку *testing*:


 >  git checkout testing


## Слияние веток и решение конфликтов 

Слияние веток происходит с помощью команды *git merge*. Для слияния содержимого другой ветки в текущую необходимо использовать команду 

 >  *git merge <название ветки>*. 
 
 Если возникнет конфликт (информация в сливаемых ветках разная в одном и том же месте), его необходимо разрешить. При конфликте можно выбрать либо текущие изменения (accept current change), либо изменения из входящей ветки (accept incoming change), либо совместить изменения двух веток (accept both changes) или увидеть, в чем разница между ними (compare changes).


## Удаление веток 

Удалить уже слитую ветку мы можем с помощью команды *git branch -d*. Для этого необходимо написать git branch -d <имя ветки>

## Скачивание удаленного репозитория 

Для получения копии существующего Git-репозитория, например, проекта, в который вы хотите внести свой вклад, необходимо использовать команду *git clone*. 

Клонирование репозитория осуществляется командой *git clone <url>*. Например, если вы хотите клонировать библиотеку *libgit2*, вы можете сделать это следующим образом:

  > $ git clone https://github.com/libgit2/libgit2

Эта команда создаёт каталог libgit2, инициализирует в нём подкаталог .git, скачивает все данные для этого репозитория и извлекает рабочую копию последней версии. Если вы перейдёте в только что созданный каталог *libgit2, то увидите в нём файлы проекта, готовые для работы или использования.

## Отправка изменений в удаленный репозиторий 
Для отправки изменений в удаленный репозиторий используется команда *git push* Для этого пишется в папке с репозиторием команда *git push origin <название ветки>*. Чаще всего используется ветка мастер 


## Pull Requests 

Для принятия изменений из ветки в ветку в нашем репозитории, или из форка удаленного репозитория, используются Pull Requests.
