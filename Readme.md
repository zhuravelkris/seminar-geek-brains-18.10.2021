
# Инструкция по работе с Git и GitHub 

Это краткая инструкция по работе с Git и GitHub, в которой будут рассмотрены основные термины, самые распространненные команды для работы с репозиториями. Помимо этого остановимся на работе с популярным сервисом  для хранения репозиториев GitHub, а так же на том, как передавать информацию от локального репозитория к удаленному и обратно, работать с репозиториями других авторов и отправлять запросы на редактуру в чужих репозиториях. 

## Что такое система контроля версий 

Система контроля версий - это программное обеспечение для облегчения работы с изменяющейся информацией. Система управления версиями позволяет хранить несколько версий одного и того же документа, при необходимости возврщаться к более ранним версиям, определять, кто и когда сделал то или иное изменение и многое другое. 


## Что такое git 

Git - это одна из реализаций распределенных систем контроля версий. Git позволяет управлять изменениями, создавать фиксации, ветки, а также сливать и удалять ветки.

## Подготовка репозитория 

Репозиторий - это хранилище файлов, поддерживающее версионность. Создать репозиторий можно с помощью команды *git init* 

## Определение состояния файлов

Основной инструмент, используемый для определения, какие файлы в каком состоянии находятся — это команда git status. Если вы выполните эту команду сразу после клонирования, вы увидите что-то вроде этого:

 >  git status

 >   On branch master
 > Your branch is up-to-date with 'origin/master'.
 
> nothing to commit, working tree clean

Это означает, что у вас чистый рабочий каталог, другими словами — в нем нет отслеживаемых измененных файлов. *Git* также не обнаружил неотслеживаемых файлов, в противном случае они бы были перечислены здесь. Наконец, команда сообщает вам на какой ветке вы находитесь и сообщает вам, что она не расходится с веткой на сервере. 

## Отслеживание новых файлов 

Для того чтобы начать отслеживать (добавить под версионный контроль) новый файл, используется команда *git add*. Чтобы начать отслеживание файла <имя файла>, вы можете выполнить следующее:

  >   *git add <имя файла>* 

Если вы снова выполните команду *status*, то увидите, что файл <имя файла> теперь отслеживаемый и добавлен в индекс.

## Создание сохранений 

Мы можем создавать "сохранения" наших версий файлов. Такие "сохранения" называются фиксациями или коммитами. Сделать коммит можно с помощью команды *git commit* и **ОБЯЗАТЕЛЬНО** использовать флаг *-m*, после чего в кавычках написать сообщение.

## Игнорирование индексации

Несмотря на то, что индекс может быть удивительно полезным для создания коммитов именно такими, как вам и хотелось, он временами несколько сложнее, чем вам нужно в процессе работы. Если у вас есть желание пропустить этап индексирования, *Git* предоставляет простой способ. Добавление параметра *-a* в команду *git commit* заставляет *Git* автоматически индексировать каждый уже отслеживаемый на момент коммита файл, позволяя вам обойтись без *git add*.

Обратите внимание, что в данном случае перед коммитом вам не нужно выполнять *git add* для файла Readme.md, потому что флаг *-a* включает все файлы. Это удобно, но будьте осторожны: флаг *-a* может включить в коммит нежелательные изменения.

## Игнорирование файлов

Зачастую, у вас имеется группа файлов, которые вы не только не хотите автоматически добавлять в репозиторий, но и видеть в списках неотслеживаемых.  В таком случае, вы можете создать файл 

  >  .gitignore.

с перечислением шаблонов соответствующих таким файлам.

Хорошая практика заключается в настройке файла 
.gitignore до того, как начать серьёзно работать, это защитит вас от случайного добавления в репозиторий файлов, которых вы там видеть не хотите.

GitHub поддерживает довольно полный список примеров .gitignore файлов для множества проектов и языков 

[GitHub] (https://github.com/github/gitignore)

это может стать отправной точкой для .gitignore в вашем проекте.

## Журнал изменений 

После того, как вы создали несколько коммитов или же клонировали репозиторий с уже существующей историей коммитов, вероятно вам понадобится возможность посмотреть что было сделано — историю коммитов. Одним из основных и наиболее мощных инструментов для этого является команда *git log*.

По умолчанию (без аргументов) *git log* перечисляет коммиты, сделанные в репозитории в обратном к хронологическому порядке — последние коммиты находятся вверху. 

С опцией *--graph* команды *log*  вы сможете увидеть небольшой граф в формате ASCII, который показывает текущую ветку и историю слияний, для этого надо написать команду:

   > git log -- graph

   
## Просмотр индексированных и неиндексированных изменений

Если результат работы команды *git status* недостаточно информативен для вас — вам хочется знать, что конкретно поменялось, а не только какие файлы были изменены — вы можете использовать команду *git diff*. 

 Вы, скорее всего, будете использовать эту команду для получения ответов на два вопроса: что вы изменили, но ещё не проиндексировали, и что вы проиндексировали и собираетесь включить в коммит. Если *git status* отвечает на эти вопросы в самом общем виде, перечисляя имена файлов, *git diff* показывает вам непосредственно добавленные и удалённые строки — патч как он есть.

 Чтобы увидеть, что же вы изменили, но пока не проиндексировали, наберите git diff без аргументов:

   > git diff

   
## Перемещение между сохранениями 

Перемещаться между нашими сохранениями можно с помощью команды *git checkout*. Для этого достаточно применить команду *git checkout <номер коммита>*. 

Можно отменить изменения с помощью команд *git revert* и *git reset*.

*git revert <номер коммита>* отменит изменения до указнной версии и создаст новый коммит. 

*git reset --hard <номер коммита>* отменит изменения до указанной версии и сотрет всю историю изменений после этого коммита.


## Ветки 

Используя ветвление, Вы отклоняетесь от основной линии разработки и продолжаете работу независимо от неё, не вмешиваясь в основную линию. Во многих СКВ создание веток — это очень затратный процесс, часто требующий создания новой копии каталога с исходным кодом, что может занять много времени для большого проекта.

Некоторые люди, говоря о модели ветвления *Git*, называют ее «киллер-фича», что выгодно выделяет Git на фоне остальных СКВ. Что в ней такого особенного? Ветвление Git очень легковесно: операция создания ветки выполняется почти мгновенно, переключение между ветками туда-сюда, обычно, также быстро. В отличие от многих других СКВ, *Git* поощряет процесс работы, при котором ветвление и слияние выполняется часто, даже по несколько раз в день. Понимание и владение этой функциональностью дает вам уникальный и мощный инструмент, который может полностью изменить привычный процесс разработки.

Новая ветка создается с помощью команды 

*git branch <название ветки>* 

## Переключение веток 

Для переключения на существующую ветку выполните команду *git checkout*. Давайте переключимся на ветку *testing*:


 >  git checkout testing


## Слияние веток и решение конфликтов 

Слияние веток происходит с помощью команды *git merge*. Для слияния содержимого другой ветки в текущую необходимо использовать команду 

 >  *git merge <название ветки>*. 
 
 Если возникнет конфликт (информация в сливаемых ветках разная в одном и том же месте), его необходимо разрешить. При конфликте можно выбрать либо текущие изменения (accept current change), либо изменения из входящей ветки (accept incoming change), либо совместить изменения двух веток (accept both changes) или увидеть, в чем разница между ними (compare changes). Помимо указанных выборов редактировать конфликт можно вручную, после чего создать коммит слияния.


## Удаление веток 

Удалить уже слитую ветку мы можем с помощью команды *git branch -d*. Для этого необходимо написать git branch -d <имя ветки>

## Скачивание удаленного репозитория 

Для получения копии существующего Git-репозитория, например, проекта, в который вы хотите внести свой вклад, необходимо использовать команду *git clone*. 

Клонирование репозитория осуществляется командой *git clone <url>*. Например, если вы хотите клонировать библиотеку *libgit2*, вы можете сделать это следующим образом:

  > $ git clone https://github.com/libgit2/libgit2

Эта команда создаёт каталог libgit2, инициализирует в нём подкаталог .git, скачивает все данные для этого репозитория и извлекает рабочую копию последней версии. Если вы перейдёте в только что созданный каталог *libgit2, то увидите в нём файлы проекта, готовые для работы или использования.


# Работа с удаленными репозиториями

Для того, чтобы внести вклад в какой-либо Git-проект, вам необходимо уметь работать с удалёнными репозиториями. 

  >   Удалённые репозитории представляют собой версии вашего проекта, сохранённые в интернете или ещё где-то в сети. 

У вас может быть несколько удалённых репозиториев, каждый из которых может быть доступен для чтения или для чтения-записи. Взаимодействие с другими пользователями предполагает управление удалёнными репозиториями, а также отправку и получение данных из них. Управление репозиториями включает в себя как умение добавлять новые, так и умение удалять устаревшие репозитории, а также умение управлять различными удалёнными ветками, объявлять их отслеживаемыми или нет и так далее. 

## Просмотр удаленных репозиториев 

Для того, чтобы просмотреть список настроенных удалённых репозиториев, вы можете запустить команду *git remote*. Она выведет названия доступных удалённых репозиториев. 

Если вы клонировали репозиторий, то увидите как минимум *origin* — имя по умолчанию, которое *Git* даёт серверу, с которого производилось клонирование:

  > git clone <адрес репозитория>

  > cd  <имя клонированного репозитория>

  > git remote 

  > origin




## Добавление удалённых репозиториев

Для того, чтобы добавить удалённый репозиторий и присвоить ему имя (shortname), просто выполните команду 

 > git remote add  <коротокое имя> <адрес репозитория>

Теперь вместо указания полного пути вы можете использовать <короткое имя>. Например, если вы хотите получить изменения, которые есть в удаленном репозитории, но нет у вас, вы можете выполнить команду 

 > git fetch <короткое имя>

 ### Получение изменений из удаленного репозитория

 Когда вы клонируете репозиторий, команда *clone* автоматически добавляет этот удалённый репозиторий под именем «origin». Таким образом, *git fetch origin* извлекает все наработки, отправленные на этот сервер после того, как вы его клонировали (или получили изменения с помощью *fetch*).
 
  Важно отметить, что команда *git fetch* забирает данные в ваш локальный репозиторий, **но не сливает** их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент. Вам необходимо вручную слить эти данные с вашими, когда вы будете готовы.

Вы можете использовать команду *git pull*, чтобы автоматически получить изменения из удалённой ветки и слить их со своей текущей. Этот способ может для вас оказаться более простым или более удобным. 

К тому же, по умолчанию команда *git clone* автоматически настраивает вашу локальную ветку master на отслеживание удалённой ветки master на сервере, с которого вы клонировали репозиторий. 

Название веток может быть другим и зависит от ветки по умолчанию на сервере. Выполнение *git pull*, как правило, извлекает (fetch) данные с сервера, с которого вы изначально клонировали, **и автоматически пытается слить (merge)** их с кодом, над которым вы в данный момент работаете.

## Отправка изменений в удаленный репозиторий 

Когда вы хотите поделиться своими наработками, вам необходимо отправить их в удалённый репозиторий. Команда для этого действия простая: 

 > git push origin <имя ветки>
 
 Чтобы отправить вашу ветку master на сервер origin (повторимся, что клонирование обычно настраивает оба этих имени автоматически), вы можете выполнить следующую команду для отправки ваших коммитов:

 > git push origin master

Эта команда срабатывает только в случае, если вы клонировали с сервера, на котором у вас есть права на запись, и если никто другой с тех пор не выполнял команду *push*. 

Если вы и кто-то ещё одновременно клонируете, затем он выполняет команду push, а после него выполнить команду *push* попытаетесь вы, то ваш *push* точно будет отклонён. Вам придётся сначала получить изменения и объединить их с вашими и только после этого вам будет позволено выполнить push. 

## Pull Requests 

Для принятия изменений из ветки в ветку в нашем репозитории, или из форка удаленного репозитория, используются Pull Requests.
